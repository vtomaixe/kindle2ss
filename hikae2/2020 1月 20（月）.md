---
Created: 2020-01-20T08:46
Updated: 2020-01-22T10:52
---
17:47

あら、Macbookの充電器、スマホに挿したら「充電してます」以上の表示「高速充電」なんてのが出たぞ。

11:51

青木氏席を試してみたが、ここもいまいちだな。暖房の風が壁を反射して届くし（マシな方だけど）、後ろに三原氏と松浦氏も座りたがるので、背や手を伸ばしづらい。休憩中にストレッチがすぐやれない。

よこの台などを使えば机の小ささはさほど気にならないが。

19:01

なんだかMacbookのディスプレイに変な画像の乱れが一瞬入る不具合が見えたのだが、これは問題になりうるのだろうか？悪化しないといいんだが。

朝の山手線、いちごうしゃ

2020 1月 20（月）,08:46

Rubyシリーズ、全部で５６くらい？

じゃあ、今日明日で一気にやるなら、今日で３０はつうかしておかないと。

さらに、これは序盤の部分の理解には貯金があるから、実際はもっとやらないと労力の等分にはならない。

一号車なら余裕で立てる。一本飛ばしてでもホームの先まで歩いて行こう

2020 1月 20（月）,08:47

女性専用車両でもないので余計な気も遣わない

2020 1月 20（月）,08:48

朝のモスバーガー、うっかり高いチーズバーガーセットを頼んでしまった。520円。

値段なりに良い味だが、bltでもいいな

2020 1月 20（月）,09:37

---

9:54

よし今日と明日でRubyのワーク出題範囲を終わらせるぞ。１からどこまで進められるか

Jsの復習も午前中にやろう。

```Plain
target.addEventListener('click', function() {
```

が、どうも気になる。target は定数なのだが。

ではまず最初のノードを削除するプログラムを書いてみましょう。

なぜ最初のノードかというとlastChildに比べてfirstChildの方が処理速度が速いためです。

>金曜頃に読んでいたときはよくわかってなかったが、つまり、最初の子ノードを消す処理を消す対象がなくなるまでループさせているから、ここの章でWhile文が出てきたとうことなのだった。

```Plain
  list.textContent = form.value;
```

>これもなんだかよく分からんな

AjaxはJQueryでもやれてる。

```Plain
          let number = $this.data('count') + 1;
```

これもよくわかってないな。

```Plain
    $('.tab li').removeClass('select');


    $(this).addClass('select');
```

Removeで全部のLiからクラスを剥がしたが、その直後に使うThisには全体ではなくあくまでクリックしたLiの情報だけを取得することになるのが知恵の生きてるところだな

軽量プログラミング言語とは，RubyやPython，JavaScriptのような，学習や取り扱いが容易なスクリプト言語を指す。プログラムの実行に必要となるメモリーが少ないという意味での「軽量」ではなく，プログラミングが容易であるという点で「軽量」と呼ばれている。PaaSでは，この軽量プログラミング言語が主流になっている。

11:44

復習終わり。やはり土日にやったぶんをまとめてやったせいでちょっと時間がかかったかな。

とはいえ、よりJsを読む力が上がった気がするので無駄ではない。

式展開を使用する際は、必ずダブルクォートでくくるようにしてください。

シングルクォートでくくると式展開として認識されず、文字列として表示されてしまいます

>これ、つまりJsと逆ってことかな？　Jsは シングルクォートに${} だったはず。

#{変数名}で呼び出すことを一般的に**変数展開**と言いますが、Rubyの場合は変数だけでなく、式も展開できます。そのため、Rubyでいう**式展開**は、変数展開も含めた意味合いとなります。

>先日のJsのワークのときにみんなが違和感ある言い方をしていたように「俺が聞こえていたのは」このせいか。先にRubyに入っていたメンバーはみんな承知済みだったのだな

「なぜ式展開を利用するのか」、「+で連結すればいいのではないか」という疑問が湧く人もいるかもしれませんが、式展開にはメリットが存在します。それは、「数値と文字列の結合は+(プラス)では連結できない」ということです。

＞ほーん。

to_iメソッドは、文字列を10進数とみなして、数値に変換してくれるメソッドです。

getsメソッドで「1」などと入力した場合の他、例えば「1番」のように単位を付けて入力しても、文字列の先頭から10進数とみなせる箇所を切り取って変換してくれます。

>やっとGetsとto_iが登場した。ここまで進んでいること前提のテストだったのか？

＞多分制限時間内に検索して理解しろということのほうが正しいか。

①else節がない

–> else節の有無に関わらず、if trueというコードでは条件式の部分がtrueのため必ずif以下の処理が実行されます。そのため、if trueと記載された時点でelse節の有無と処理結果には関連性が無くなります。

>なるほｄ．

```Plain
# aをgets.to_iで取得
irb(main):004:0> a = gets.to_i
5


# 数値として読まれている
=> 5
```

ぼーっと読み飛ばすところだったが、これは、gets後にターミナルで入力されたものは自動的に変数aにいれるぞ、という宣言である。これがきちんとわかってないと次が想像できない

※実行例中の\n（※1などの箇所）は、**「改行文字」**と言い、システム（PC）が改行を認識するための **制御文字** です。getsメソッドでキーボードから文字を取得する際、末尾に必ずこの改行文字が含まれます。

if文が「もし〜であればAの処理を実行する」というのに対し、「もし〜でなければBの処理を行う」と、条件が「偽」のときに処理が行われます。

>If文に初期値でTrueが入っているのはこのせいかな？

※unless文ではelseを使用することはできますが、elsifを使用して複数の条件分岐を行うことはできないので気をつけましょう。

＞え、じゃあIfより条件分岐の特徴が弱いじゃん

case-whenの文は、JsのSwitch-Caseの文に似ているな

```Plain
case age
when 10
  puts "私はまだまだ子供です"
when 20 \#ここでcaseの値と一致する
  puts "成人になりました"
when 60
  puts "定年です"
else
  puts ""
end
```

if文はあらゆる条件を書くのに便利な一般的な条件文の形式と考えてください。case文は、ある値に基づいて場合分けをしていく場合に有効です。有効というか、見やすいといった方がいいですね。case という意味は、場合分けの意味を表すので・・

プログラムは、できるだけ、見やすく分かりやすくきれいであることが大事です。

このように実装することで、繰り返し続ける条件が満たされている場合（trueの場合）、while文の中の処理が繰り返されます。条件式をtrueにすることで、処理が停止されない限り、処理を継続させることができます。

これは想像できなかった。たぶんファイルの後ろの方に書くんだろうと思っていた。

inの後の0..10の記述は「0以上10以下」という範囲指定を表します。その値(0~10)を変数numberに0から **順に** 代入し出力しています。

※順に代入されているため、値がランダムに出力されることはありません。

＞あ、もう最初からi++の状態になってるってことね。

でたー、Times処理！

事前テストのアレは、

最初の値をTimes処理に入るよう変数を設定、

年数は配列を作ってそれに格納し、

IF文かCase文で、変数そのものではなくIndex値（あるいはハッシュにしてキー値）を参照して分岐させる処理ならより短くまとまったのでは？

いや、分岐がきっちりできるならそもそもTimes処理はいらないか

配列には要素を後から追加することもできます。

配列に要素を追加する場合は<<を使って追加できます。

>やはり、ｊｓにくらべるとだいぶコードがスッキリしてるのがわかる。

しかし、ハッシュロケットによる記法はいささか古いものであるようです。特にこの先Ruby on Railsを学ぶ者にとっては、Railsの作法にのっとり、シンボル記法を今のうちから使用しておいたほうが無難です。

※ロケット記法より、シンボル記法のほうが実行速度が速い、というメリットもあります。参考までに覚えておくといいでしょう。

＞へー。

```Plain
puts players_count[:soccer]
```

ハッシュも配列もそうだが、作るときと呼び出すときでカッコ使い方がちょっと違うのは、なんだか困るなあ。波だったり大かっこだったり。

＞ひらめいた。ハッシュを作る名前として波括弧を使うが、キー値≒インデックス値を表現し操作するため、[]の大角カッコを使っているんだ。むしろ配列の方が、定義とインデックスとで同じカッコを使っているとすら言える？

つまり、ハッシュ名作成のため最初に使われた波括弧は、その後の操作からはこちらの目に見えなくなるので、インデックス値用の[]しか出番がなくなるということだ。

ハッシュ用のキー値もラベルを張ってある＝文字列ばっかなので、””でいちいち囲むのは当たり前である。

追加したら常に最後尾に回されるので、追加時にいちいち既存のハッシュのキー値をどうこうする操作は起きない。

```Plain
teachers << "matsumoto"
```

15:53

ねむすぎてRuby入門22【配列とハッシュの操作について】　の課題がよくわからない

```Plain
test = [{subject: "math", points: 70}, {subject: "english", points: 50}, {subject: "society", points: 80}]


test << {subject: "science", points: 100} # 2


puts test[3][:points] # 3
```

つまり、単純な配列追加のコマンドを骨にして、変数要素の部分を新ハッシュの定義の記法に変えることで追加するコマンドになっている。

追加対象のお題の配列は、特にインデックス番号があるわけではない。インデックス番号１番となりうる箱が無い。

よって、配列の形をしているが、ハッシュが仕込まれている位置はインデックス番号０なのだ。

ハッシュの場合キーで管理するため、順番を覚えなければいけないなどの問題が発生する頻度を減らすことができます。

＞確かに、番号を計算する必要がない。名前さえはっきりしていれば、順番管理はコンピュータ側の仕事だ。

結果として、配列とハッシュの使い分けに関して以下のことが言えます。

```Plain
中の情報が特にそれぞれ何か紐付いてない場合：配列
中の情報がそれぞれ何かと紐付いている場合：ハッシュ
```

11:37

まいったな、何だか集中できないぞ。寝不足のせいか？

12:11

ほー、自作メソッド？　関数と何が違うんだ？

>名前が違うだけで同じじゃん、英名もFunctionだし

関数とメソッドは同じようなものと考えて大丈夫です！

しかし、呼び方はメソッドと呼ぶ方がオブジェクト指向的に正解です。

[https://qiita.com/jnchito/items/68cfd77d4b2129cb3adc](https://qiita.com/jnchito/items/68cfd77d4b2129cb3adc)

```Plain
def weather


  ["晴れ", "雨", "曇り"].each do |i|
    puts "i"


  end
```

>これでは動かない。Each文がひとつの条件文みたいなものなのだから、each部分ひとつに対してひとつの対応するEndが要る。

だが書いた時点ではDef=メソッド定義の部分を閉じるためのEndだけでいいと勘違いしているので、Endが足らないのである。

ちゃーんとコンソールのエラー示唆はこのことを教えている。

Ruby演習が終わって、ようやく問題のアルゴリズムに入ることになった。

このパートは全１２。

明日の夕方までに終わらせるとすると、今日であと２つかそのくらい？

下読みとして全部さらっと眺めてみるか？

16:36

アルゴリズム開始

17:15

入門３から演習問題が出てくる。

入門３＿中間値の取得アルゴリズムと、その実装

演習１　3.問題 文字列の長さを求めるアルゴリズム

演習２　3.問1　リピートワードアルゴリズム

問2　HogeHogeアルゴリズム

１から４０までの数字の中で、３の倍数と３のつく数字だけHogeと出力されるアルゴリズムを作成

文字変換アルゴリズム

与えられた文字列の大文字と小文字を入れ替える

Rubyアルゴリズム・データ構造シリーズでは、クイックソートやバブルソートといった、より実践的なアルゴリズムについて学んでいきます。

＞これが全６回

＞古典的アルゴリズムの種類も名前が出てくる。

＞それをコードで実装してみろ、という内容。こりゃあ確かに難しそうだ

＞ソートの動きを見て、数字を入れてチャートにし、それからそのチャートの動き、動画、判断の行方をフローチャートを動かしながら覚えて、そののちコード化、かな？

再帰処理とは、関数の中でその関数自身を呼び出す処理のことを指す。

＞いやまあ知ってるが、あくまで関数の中（メソッドの中だけ？）ってことか

こちらのカリキュラムや、カリキュラムの小課題はCS(Computer Science)未経験者には少々難易度が高いので、このカリキュラムを一読して全てを理解しなくてはいけない（0から自分で全て実装できるようにならなくてはいけない）ということはありません。一回ですべてできる、ということが重要なのではなく、まずやってみて、そのあとに答えを確認して考え方を学ぶ、というサイクルが重要です。この章の小課題はできなくても構わないので、小課題の答えをしっかりと理解してください。

＞だってさ。

古典的なアルゴリズムに取り組む上で必要なのは、難しい数学の知識ではなく、論理的に考える力と反復練習です。

＞ほう。

＞文字より動画教材がほしいな

＞応用情報の試験を思い出すなあ。苦手だったっけ、もう１０年も前のことだ

アルゴリズムは情報処理の分野であり、いわばパズルをひたすら解いていくような学問領域となります。

そのため、プログラミングのルールを覚えてコードを書くこととは違った頭の使い方が必要になり、 経験のない方にはとても難しい ものとなります。しかし、ゆくゆくは第一線で活躍するエンジニアとなることを目指すのであれば、基本的なアルゴリズム、そしてアルゴリズムを構築していける頭の動かし方は必要不可欠なものです。多少辛くとも踏ん張って学習していきましょう。

＞うわあ、おっそろしいこと書いてあるなあ

```Plain
factorial(5)
→factorial(4)を呼び出し
 →factorial(3)を呼び出し
  →factorial(2)を呼び出し
   →factorial(1)を呼び出し


```

結果として、5 * 4 * 3 * 2 * 1 * 1 という計算が実行され、5!(120)の値を得ることができます。

ポモドーロメソッド、なんとDiverのテキストの中に出てきてる。

そうとは知らずに先にこのテキストを消化した三原さんに講釈たれたとは、ああ恥ずかしい。

18:06

gem install launchy

を実行してインストール済み

Ms.Minnie

これがHotlineMiamiの電子マンガ版に使われてたBGM

---

このようにオブジェクトとメソッドはセットの関係にありながら、あるオブジェクトに対して使用できるメソッドは限られているということです。

>文字列を計算しろ、なんて無理なわけだしな

.touch は正確にはファイル生成のためのコマンドではない？　説明ブログをよく見るが、ツッコミのコメントが気になった。もしや連絡しろ、の意味のtouchか？

だが、UNIXについて調べなきゃいけなさそうなので、Diverから外れる。UNIXの公式リファレンスを見ろってことか？時間があるときにまた。

確かに、ファイル生成としては少々違和感を覚える単語選びなのは確かだ。