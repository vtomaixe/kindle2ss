---
Created: 2020-02-25T09:07
Updated: 2020-04-11T09:27
---
恐れていたとおり、英検もプログラミングもどっちつかずのまま三連休を終えてしまった

もう今回の英検二次は諦めるか。

2020 2月 25（火）,09:07

- ------

・書式を削除、のメニュー. evernoteブラウザ版画面右上。

favoriteを追加するならfavorites（複数形）、削除するならfavorite（単数形）。

これはRailsが決めたことなのでとりあえず覚えろ！？

12:16

インスタグラムクローン、勝ったケロ。

ログイン・ログアウト、（これは多くの現場ではGemのDeviseでやってる？）

お気に入りにまつわるアソシエーション、

ブートストラップを使ったデコレーション、レイアウト、

コードを追っかけた正確なルーティング。

いろいろ課題は残った。

'pry-rails'

# コンソールをirbからpryに置き換える。

[irb](https://pikawaka.com/ruby/irb)でもメソッドなどが使えるのですが、Pry（プライ）だとより高度なことをすることができます。

それではPryはどういったときに使うのでしょうか？

例えば投稿フォームに入力した情報がデータベースに保存されないというエラーが発生したとします。

そういった場合、原因がどのコードにあるのかをPryを使って確認することができます。

ここで登場するのがbinding.pryです。

binding.pry

binding.pryという文字列をコード内に記述すると、そこがブレイクポイントとなりrailsの処理を止めることができます。

how-routes 現在のルーティングを確認

show-models 現在のモデルを確認

show-source クラスやモジュール、メソッドの定義を確認

show-doc クラスやモジュール、メソッドのドキュメントを確認

などなど。

alias（エイリアス）とはコマンドを別名で登録したものです。

ショートカットのようなものとイメージするとわかりやすいです。

BETTER ERRORS

また、単純な変数チェックをするときはコード中に「raise」と入れてあげると動作が止まってそこまでの変数をチェック出来るので使っています。pry-railsでいう「binding.pry」と同じように使っています。

（正しい使い方かは知りませんが、とりあえず出来る）

better_errorsはデフォルトのエラー画面をわかりやすく成形してくれるgem。

binding_of_callerはそのエラー画面にirbをつけてくれるgem。

GitHub Flowとは何だろうか？

– masterブランチのものは何であれデプロイ可能である– 新しい何かに取り組む際は、説明的な名前のブランチをmasterから作成する（例: new-oauth2-scopes）– 作成したブランチにローカルでコミットし、サーバー上の同じ名前のブランチにも定期的に作業内容をpushする– フィードバックや助言が欲しい時、ブランチをマージしてもよいと思ったときは、 プルリクエスト を作成する– 他の誰かがレビューをして機能にOKを出してくれたら、あなたはコードをmasterへマージすることができる– マージをしてmasterへpushしたら、直ちにデプロイをする

これがフローのすべてだ。 とてもシンプルかつ効率的で、かなり大きなチームでも機能する。

### [**1 関連付けを使う理由**](https://railsguides.jp/association_basics.html#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%92%E4%BD%BF%E3%81%86%E7%90%86%E7%94%B1)

Railsでは、「関連付け(アソシエーション: association)」とは2つのActive Recordモデル同士のつながりを指します。

モデルとモデルの間には関連付けを行なう必要がありますが、その理由を御存じでしょうか。それは、関連付けを行う事であなたのコードでの共通操作をよりシンプルで簡単にするからです。簡単なRailsアプリケーションを例にとって説明しましょう。このアプリケーションには著者用のモデル(Author)と書籍用のモデル(Book)があります。一人の著者は、複数の書籍を持っています。関連付けを設定していない状態では、モデルの宣言は以下のようになります。

```Plain
class Author < ApplicationRecord
end
class Book < ApplicationRecord
end
```

ここで、既存の著者が新しい書籍を1つ執筆したくなったとします。この場合、以下のようなコードを実行する必要があるでしょう。

```Plain
@book = Book.create(published_at: Time.now, author_id: @author.id)
```

今度は著者を削除する場合を考えてみましょう。著者を削除するなら、以下のように、執筆した書籍も残らず削除されるようにしておかなければなりません。

```Plain
@books = Book.where(author_id: @author.id)
@books.each do |book|
  book.destroy
end
@author.destroy
```

Active Recordの関連付け機能を使うと、2つのモデルの間につながりがあることを明示的にRailsに対して宣言でき、それによってモデルの操作を一貫させることができます。著者と書籍の設定するコードを次のように書き直せます。

```Plain
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end
class Book < ApplicationRecord
  belongs_to :author
end
```

上のように関連付けを追加したことで、特定の著者用に新しい書籍を1つ追加する作業が以下のように一行でできるようになりました。

```Plain
@book = @author.books.create(published_at: Time.now)
```

著者と、その著者の書籍をまとめて削除する作業はさらに簡単です。

```Plain
@author.destroy
```

その他の関連付け方法については、次の節をお読みください。それに続いて、関連付けに関するさまざまなヒントや活用方法、Railsの関連付けメソッドとオプションの完全な参照物もご紹介します。

### [**2 関連付けの種類**](https://railsguides.jp/association_basics.html#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E7%A8%AE%E9%A1%9E)

Railsでサポートされている関連付けは以下の6種類です。

- belongs_to
- has_one
- has_many
- has_many :through
- has_one :through
- has_and_belongs_to_many

関連付けは、一種のマクロ的な呼び出しとして実装されており、これによってモデル間の関連付けを宣言的に追加できます。たとえば、あるモデルが他のモデルに従属している(belongs_to)と宣言すると、2つのモデルのそれぞれのインスタンス間で「[主キー](https://ja.wikipedia.org/wiki/%E4%B8%BB%E3%82%AD%E3%83%BC) - [外部キー](https://ja.wikipedia.org/wiki/%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC)」情報を保持しておくようにRailsに指示が伝わります。同時に、いくつかの便利なメソッドもそのモデルに追加されます。

本ガイドではこの後、それぞれの関連付けの宣言方法と利用方法について詳しく解説します。その前に、それぞれの関連付けが適切となる状況について簡単にご紹介しましょう。

### [**2.1 belongs_to関連付け**](https://railsguides.jp/association_basics.html#belongs-to%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

あるモデルでbelongs_to関連付けを行なうと、他方のモデルとの間に「1対1」のつながりが設定されます。このとき、宣言を行ったモデルのすべてのインスタンスは、他方のモデルのインスタンスに「従属(belongs to)」します。たとえば、Railsアプリケーションに著者(Author)と書籍(Book)情報が含まれており、１冊の書籍につき正確に１人の著者を割り当てたいのであれば、Bookモデルで以下のように宣言します。

```Plain
class Book < ApplicationRecord
  belongs_to :author
end
```

![[untitled 838]]

belongs_to関連付けで指定するモデル名は必ず「**単数形**」にしなければなりません。上記の例で、Bookモデルのauthor関連付けを複数形（authors）にしてからBook.create(authors: @author)でインスタンスを作成しようとすると、「uninitialized constant Book::Authors」エラーが発生します。Railsは、関連付けの名前から自動的にモデルのクラス名を推測します。従って、関連付け名が誤って複数形になってしまっていると、そこから推測されるクラス名も誤った形の複数形になってしまいます。

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string  :name
      t.timestamps
    end
    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

### [**2.2 has_one関連付け**](https://railsguides.jp/association_basics.html#has-one%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

has_one関連付けも、他方のモデルとの間に1対1の関連付けを設定します。しかし、その意味と結果はbelongs_toとは若干異なります。has_one関連付けの場合は、その宣言が行われているモデルのインスタンスが、他方のモデルのインスタンスを「まるごと含んでいる」または「所有している」ことを示します。たとえば、供給者(supplier)1人につきアカウント(account)を1つだけ持つという関係があるのであれば、以下のように宣言を行います。

```Plain
class Supplier < ApplicationRecord
  has_one :account
end
```

![[untitled 839]]

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateSuppliers < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end
    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```

ユースケースにもよりますが、アカウントとの関連付けのために、供給者のカラムに一意のインデックスや外部キー制約を追加する必要もある場合もあります。その場合、カラムの定義は次のようになる可能性があります。

```Plain
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
  # ...
end
```

### [**2.3 has_many関連付け**](https://railsguides.jp/association_basics.html#has-many%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

has_many関連付けは、他のモデルとの間に「1対多」のつながりがあることを示します。has_many関連付けが使われている場合、「反対側」のモデルでは多くの場合belongs_toが使われます。has_many関連付けが使われている場合、そのモデルのインスタンスは、反対側のモデルの「0個以上の」インスタンスを所有します。たとえば、著者(Author)と書籍(Book)を含むRailsアプリケーションでは、著者のモデルを以下のように宣言できます。

```Plain
class Author < ApplicationRecord
  has_many :books
end
```

has_many関連付けを宣言する場合、相手のモデル名は「複数形」にする必要があります。

![[untitled 840]]

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateAuthors < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string  :name
      t.timestamps
    end
    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```

### [**2.4 has_many :through関連付け**](https://railsguides.jp/association_basics.html#has-many-through%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

has_many :through関連付けは、他方のモデルと「多対多」のつながりを設定する場合によく使われます。この関連付けは、2つのモデルの間に「第3のモデル」(joinモデル)が介在する点が特徴です。それによって、相手モデルの「0個以上」のインスタンスとマッチします。たとえば、患者(patient)が医師(physician)との診察予約(appointment)を取る医療業務を考えてみます。この場合、関連付けは次のような感じになるでしょう。

```Plain
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end
class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end
class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```

![[untitled 841]]

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateAppointments < ActiveRecord::Migration[5.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end
    create_table :patients do |t|
      t.string :name
      t.timestamps
    end
    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```

joinモデル(結合モデル)のコレクションは、[has_many](https://railsguides.jp/association_basics.html#has-many%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)経由で管理できます。たとえば、以下のような割り当てを実行したとします。

```Plain
physician.patients = patients
```

このとき、新たに関連付けられたオブジェクトについて、新しいjoinモデルが自動的に作成されます。結合時に不足している部分があれば、その行はjoinモデルから削除され、joinモデルに含まれなくなります。

モデル結合時の不足分自動削除は即座に行われます。さらに、その際にdestroyコールバックはトリガーされませんので注意が必要です。

has_many :through関連付けは、ネストしたhas_many関連付けを介して「ショートカット」を設定する場合にも便利です。たとえば、1つのドキュメントに多くの節(section)があり、1つの節の下に多くの段落(paragraph)がある状態で、節をスキップしてドキュメントの下のすべての段落の単純なコレクションが欲しいとします。その場合、以下の方法で設定できます。

```Plain
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end
class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end
class Paragraph < ApplicationRecord
  belongs_to :section
end
```

through: :sectionsと指定することにより、Railsは以下の文を理解できるようになります。

```Plain
@document.paragraphs
```

### [**2.5 has_one :through関連付け**](https://railsguides.jp/association_basics.html#has-one-through%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

has_one :through関連付けは、他方のモデルに対して「1対1」のつながりを設定します。この関連付けは、2つのモデルの間に「第3のモデル」(joinモデル)が介在する点が特徴です。それによって、相手モデルの1つのインスタンスとマッチします。たとえば、1人の提供者(supplier)が1つのアカウントに関連付けられ、さらに1つのアカウントが1つのアカウント履歴に関連付けられる場合、supplierモデルは以下のような感じになります。

```Plain
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end
class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end
class AccountHistory < ApplicationRecord
  belongs_to :account
end
```

![[untitled 842]]

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateAccountHistories < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end
    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```

### [**2.6 has_and_belongs_to_many関連付け**](https://railsguides.jp/association_basics.html#has-and-belongs-to-many%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

has_and_belongs_to_many関連付けは、他方のモデルと「多対多」のつながりを作成しますが、through:を指定した場合と異なり、第3のモデル(joinモデル)が介在しません(訳注: 後述するように結合用のテーブルは必要です)。たとえば、アプリケーションに完成品(assembly)と部品(part)があり、1つの完成品に多数の部品が対応し、逆に1つの部品にも多くの完成品が対応するのであれば、モデルの宣言は以下のようになります。

```Plain
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end
class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

[![](https://railsguides.jp/railsguides/images/habtm.png)](https://railsguides.jp/railsguides/images/habtm.png)

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateAssembliesAndParts < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies do |t|
      t.string  :name
      t.timestamps
    end
    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end
    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```

### [**2.7 belongs_toとhas_oneのどちらを選ぶか**](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A8has-one%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%82%92%E9%81%B8%E3%81%B6%E3%81%8B)

2つのモデルの間に1対1の関係を作りたいのであれば、いずれか一方のモデルにbelongs_toを追加し、もう一方のモデルにhas_oneを追加する必要があります。どちらの関連付けをどちらのモデルに置けばよいのでしょうか。

区別の決め手となるのは外部キー(foreign key)をどちらに置くかです(外部キーは、belongs_toを追加した方のモデルのテーブルに追加されます)。もちろんこれだけでは決められません。データの実際の意味についてもう少し考えてみる必要があります。has_oneというリレーションは、主語となるものが目的語となるものを「所有している」ということを表しています。そして、所有されている側(目的語)の方が、所有している側(主語)を指し示しているということも表しています。たとえば、「供給者がアカウントを持っている」とみなす方が、「アカウントが供給者を持っている」と考えるよりも自然です。つまり、この場合の正しい関係は以下のようになります。

```Plain
class Supplier < ApplicationRecord
  has_one :account
end
class Account < ApplicationRecord
  belongs_to :supplier
end
```

上の関連付けに対応するマイグレーションは以下のような感じになります。

```Plain
class CreateSuppliers < ActiveRecord::Migration[5.2]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end
    create_table :accounts do |t|
      t.bigint  :supplier_id
      t.string  :account_number
      t.timestamps
    end
    add_index :accounts, :supplier_id
  end
end
```

マイグレーションでt.bigint :supplier_idのように「小文字のモデル名_id」と書くと、外部キーを明示的に指定できます。現在のバージョンのRailsでは、同じことをt.references :supplierという方法で記述できます。こちらの方が実装の詳細が抽象化され、隠蔽されます。

### [**2.8 has_many :throughとhas_and_belongs_to_manyのどちらを選ぶか**](https://railsguides.jp/association_basics.html#has-many-through%E3%81%A8has-and-belongs-to-many%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%82%92%E9%81%B8%E3%81%B6%E3%81%8B)

Railsでは、モデル間の多対多リレーションシップを宣言するのに2とおりの方法が利用できます。簡単なのはhas_and_belongs_to_manyを使う方法です。この方法では関連付けを直接指定できます。

```Plain
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end
class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

多対多のリレーションシップを宣言するもう1つの方法はhas_many :throughです。こちらの場合は、joinモデルによる間接的な関連付けが使われます。

```Plain
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end
class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end
class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```

どちらを使うかについてですが、経験上、リレーションシップのモデルそれ自体を独立したエンティティとして扱いたい(両モデルの関係そのものについて処理を行いたい)のであれば、中間にjoinモデルを使うhas_many :throughリレーションシップを選ぶのが最もシンプルです。リレーションシップのモデルで何か特別なことをする必要がまったくないのであれば、joinモデルの不要なhas_and_belongs_to_manyリレーションシップを使うのがシンプルです(ただし、こちらの場合はjoinモデルが不要な代わりに、専用のjoinテーブルを別途データベースに作成しておく必要がありますので、お忘れなきよう)。

joinモデルで検証(validation)、コールバック、追加の属性が必要な場合は、has_many :throughをお使いください。

### [**2.9 ポリモーフィック関連付け**](https://railsguides.jp/association_basics.html#%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

_ポリモーフィック関連付け_は、関連付けのやや高度な応用です。ポリモーフィック関連付けを使うと、ある1つのモデルが他の複数のモデルに属していることを、1つの関連付けだけで表現できます。たとえば、写真(picture)モデルがあり、このモデルを従業員(employee)モデルと製品(product)モデルの両方に従属させたいとします。この場合は以下のように宣言します。

```Plain
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end
class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end
class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```

ポリモーフィックなbelongs_toは、他のあらゆるモデルから利用できる、(デザインパターンで言うところの)インターフェイスを設定する宣言とみなすこともできます。@employee.picturesとすると、写真のコレクションをEmployeeモデルのインスタンスから取得できます。

同様に、@product.picturesとすれば写真のコレクションをProductモデルのインスタンスから取得できます。

Pictureモデルのインスタンスがあれば、@picture.imageableとすることで親を取得できます。これができるようにするためには、ポリモーフィックなインターフェイスを使うモデルで、外部キーのカラムと型のカラムを両方とも宣言しておく必要があります。

```Plain
class CreatePictures < ActiveRecord::Migration[5.2]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```

t.referencesという書式を使うとさらにシンプルにできます。

```Plain
class CreatePictures < ActiveRecord::Migration[5.2]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end
```

![[untitled 843]]

### [**2.10 自己結合**](https://railsguides.jp/association_basics.html#%E8%87%AA%E5%B7%B1%E7%B5%90%E5%90%88)

データモデルを設計していると、時に自分自身に関連付けられる必要のあるモデルに出会うことがあります。たとえば、1つのデータベースモデルに全従業員を格納しておきたいが、マネージャーと部下(subordinate)の関係も追えるようにしておきたい場合が考えられます。この状況は、自己結合関連付けを用いてモデル化できます。

```Plain
class Employee < ApplicationRecord
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"
  belongs_to :manager, class_name: "Employee", optional: true
end
```

上のように宣言しておくと、@employee.subordinatesと@employee.managerが使えるようになります。

マイグレーションおよびスキーマでは、モデル自身にreferencesカラムを追加します。

```Plain
class CreateEmployees < ActiveRecord::Migration[5.0]
  def change
    create_table :employees do |t|
      t.references :manager
      t.timestamps
    end
  end
end
```

### [**3 ヒントと注意事項**](https://railsguides.jp/association_basics.html#%E3%83%92%E3%83%B3%E3%83%88%E3%81%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85)

RailsアプリケーションでActive Recordの関連付けを効率的に使うためには、以下について知っておく必要があります。

- キャッシュ制御
- 名前衝突の回避
- スキーマの更新
- 関連付けのスコープ制御
- 双方向関連付け

### [**3.1 キャッシュ制御**](https://railsguides.jp/association_basics.html#%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E5%88%B6%E5%BE%A1)

関連付けのメソッドは、すべてキャッシュを中心に構築されています。最後に実行したクエリの結果はキャッシュに保持され、次回以降の操作で利用できます。このキャッシュはメソッド間でも共有されることに注意してください。例:

```Plain
author.books                # データベースからbooksを取得する
author.books.size            # booksのキャッシュコピーが使われる
author.books.empty?          # booksのキャッシュコピーが使われる
```

データがアプリケーションの他の部分によって更新されている可能性に対応するために、キャッシュを再読み込みするにはどうしたらよいでしょうか。その場合は関連付けのメソッド呼び出しでreloadを指定するだけで、キャッシュが破棄されてデータが再読み込みされます。

```Plain
author.books                # データベースからbooksを取得する
author.books.size            # booksのキャッシュコピーが使われる
author.books.reload.empty?  # booksのキャッシュコピーが破棄される
                            # その後データベースから再度読み込まれる
```

### [**3.2 名前衝突の回避**](https://railsguides.jp/association_basics.html#%E5%90%8D%E5%89%8D%E8%A1%9D%E7%AA%81%E3%81%AE%E5%9B%9E%E9%81%BF)

関連付けにはどんな名前でも使えるとは限りません。関連付けを作成すると、モデルにその名前のメソッドが追加されます。従って、ActiveRecord::Baseのインスタンスで既に使われているような名前を関連付けに使うのは禁物です。そのような名前を関連付けに使うと、基底メソッドが上書きされて不具合が生じる可能性があります。attributesやconnectionは関連付けに使ってはならない名前の例です。

### [**3.3 スキーマの更新**](https://railsguides.jp/association_basics.html#%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E%E3%81%AE%E6%9B%B4%E6%96%B0)

関連付けはきわめて便利ですが、残念ながら全自動の魔法ではありません。関連付けを使うからには、関連付けの設定に合わせてデータベースのスキーマを常に更新しておく責任が生じます。作成した関連付けにもよりますが、具体的には次の2つの作業が必要になります。1. belongs_to関連付けを使う場合は、外部キーを作成する必要があります。2. has_and_belongs_to_many関連付けを使う場合は、適切なjoinテーブルを作成する必要があります。

### [**3.3.1 belongs_to関連付けに対応する外部キーを作成する**](https://railsguides.jp/association_basics.html#belongs-to%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B)

belongs_to関連付けを宣言したら、対応する外部キーを作成する必要があります。以下のモデルを例にとります。

```Plain
class Book < ApplicationRecord
  belongs_to :author
end
```

上の宣言は、以下のようにbooksテーブル上の対応する外部キーカラムと整合している必要があります。作成した直後のテーブルの場合、マイグレーションは次のような感じになります。

```Plain
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :books do |t|
      t.datetime :published_at
      t.string  :book_number
      t.references :author
    end
  end
end
```

一方、既存のテーブルの場合、マイグレーションは次のような感じになります。

```Plain
class AddAuthorToBooks < ActiveRecord::Migration[5.0]
  def change
    add_reference :books, :author
  end
end
```

[データベースレベルでの参照整合性を強制する](https://railsguides.jp/active_record_migrations.html#%E5%A4%96%E9%83%A8%E3%82%AD%E3%83%BC)には、上の‘reference’カラム宣言にforeign_key: trueオプションを追加します。

### [**3.3.2 has_and_belongs_to_many関連付けに対応するjoinテーブルを作成する**](https://railsguides.jp/association_basics.html#has-and-belongs-to-many%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8Bjoin%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B)

has_and_belongs_to_many関連付けを作成した場合は、それに対応するjoin(結合)テーブルを明示的に作成する必要があります。:join_tableオプションを使って明示的にjoinテーブルの名前が指定されていない場合、Active Recordは2つのクラス名を辞書の並び順に結合して、joinテーブル名を作成します。たとえばAuthorモデルとBookモデルを結合する場合、'a'は辞書で'b'より先に出現するので "authors_books"というデフォルトのjoinテーブル名が使われます。

モデル名の並び順はStringクラスの<=>演算子を用いて算出されます。これは、2つの文字列の長さが異なり、短い方が長い方の途中まで完全に一致しているような場合、長い方の文字列は短い方よりも辞書上の並び順が前として扱われるということです。たとえば、"paper_boxes" テーブルと "papers" テーブルがある場合、これらを結合すれば "papers_paper_boxes" となると推測されます。 "paper_boxes" の方が長いので、常識的には並び順が後ろになると予測できるからです。しかし実際のjoinテーブル名は "paper_boxes_papers" になってしまいます。これはアンダースコア '_' の方が 's' よりも並び順が前になるためです。

生成された名前がどのようなものであれ、適切なマイグレーションを実行してjoinテーブルを生成する必要があります。以下の関連付けを例にとって考えてみましょう。

```Plain
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end
class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```

この関連付けに対応する assemblies_parts テーブルをマイグレーションで作成し、裏付けておく必要があります。このテーブルには主キーを設定しないでください。

```Plain
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end
    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```

このテーブルはモデルを表さないので、create_tableにid: falseを渡します。こうしておかないとこの関連付けは正常に動作しません。モデルのIDが破損する、IDの競合で例外が発生するなど、has_and_belongs_to_many関連付けの動作が怪しい場合は、この設定を忘れていないかどうか再度確認してみてください。

create_join_tableメソッドを使うことも可能です。

```Plain
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```

### [**3.4 関連付けのスコープ制御**](https://railsguides.jp/association_basics.html#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E5%88%B6%E5%BE%A1)

デフォルトでは、関連付けによって探索されるオブジェクトは、現在のモジュールのスコープ内のものだけです。Active Recordモデルをモジュール内で宣言している場合、この点に注意する必要があります。例：

```Plain
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

上のコードは正常に動作します。これは、SupplierクラスとAccountクラスが同じスコープ内で定義されているためです。しかし下のコードは動作しません。SupplierクラスとAccountクラスが異なるスコープ内で定義されているためです。

```Plain
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end
  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```

あるモデルと異なる名前空間にあるモデルを関連付けるには、関連付けの宣言で完全なクラス名を指定する必要があります

```Plain
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
      class_name: "MyApplication::Billing::Account"
    end
  end
  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
      class_name: "MyApplication::Business::Supplier"
    end
  end
end
```

### [**3.5 双方向関連付け**](https://railsguides.jp/association_basics.html#%E5%8F%8C%E6%96%B9%E5%90%91%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)

関連付けは、通常双方向で設定します。2つのモデル両方に関連を定義する必要があります。

```Plain
class Author < ApplicationRecord
  has_many :books
end
class Book < ApplicationRecord
  belongs_to :author
end
```

Active Recordは関連付けの設定から、これら２つのモデルが双方向の関連を共有していることを自動的に認識します。以下に示すとおり、Active RecordはAuthorオブジェクトのコピーを１つだけ読み出し、アプリケーションをより効率的かつ一貫性のあるデータに仕上げます。

```Plain
a = Author.first
b = a.books.first
a.first_name == b.author.first_name # => true
a.first_name = 'David'
a.first_name == b.author.first_name # => true
```

Active Recordでは標準的な名前同士の関連付けのほとんどをサポートしていて、自動的に認識できます。ただし、Active Recordでスコープや次のオプションを使った場合、双方向の関連付けは自動的に認識されません。

- :through
- :foreign_key

たとえば、次のようなモデルを宣言したケースを考えてみましょう。

```Plain
class Author < ApplicationRecord
  has_many :books
end
class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

この場合、Active Recordは双方向の関連付けを自動的に認識しません。

```Plain
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => false
```

Active Recordは:inverse_ofオプションを提供していて、これを使うと双方向の関連付けを明示的に宣言できます。

```Plain
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end
class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```

has_manyの関連付けを宣言するときに:inverse_ofオプションも含めることで、Active Recordは双方向の関連付けを認識するようになります。

```Plain
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => true
```

### [**4 関連付けの詳細情報**](https://railsguides.jp/association_basics.html#%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0%E6%83%85%E5%A0%B1)

この節では、各関連付けの詳細を解説します。関連付けの宣言によって追加されるメソッドやオプションについても説明します。

### [**4.1 belongs_to関連付けの詳細**](https://railsguides.jp/association_basics.html#belongs-to%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0)

belongs_to関連付けは、別のモデルとの間に1対1の関連付けを作成します。データベースの用語で説明すると、この関連付けが行われているクラスには外部キーがあるということです。外部キーが自分のクラスではなく相手のクラスにあるのであれば、belongs_toではなくhas_oneを使う必要があります。

### [**4.1.1 belongs_toで追加されるメソッド**](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89)

belongs_to関連付けを宣言したクラスでは、以下の6つのメソッドを自動的に利用できるようになります。

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association

これらのメソッドのうち、associationの部分はプレースホルダであり、belongs_toの最初の引数である関連付け名をシンボルにしたものに置き換えられます。例えば次のように宣言をした場合

```Plain
class Book < ApplicationRecord
  belongs_to :author
end
```

Bookモデルのインスタンスで以下のメソッドが使えるようになります。

```Plain
author
author=
build_author
create_author
create_author!
reload_author
```

新しく作成したhas_one関連付けまたはbelongs_to関連付けを初期化するには、build_で始まるメソッドを使う必要があります。この場合has_many関連付けやhas_and_belongs_to_many関連付けで使われるassociation.buildメソッドは使わないでください。作成するには、create_で始まるメソッドをお使いください。

### [4.1.1.1 association](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-association)

associationメソッドは関連付けられたオブジェクトを返します。関連付けられたオブジェクトがない場合はnilを返します。

```Plain
@author = @book.author
```

関連付けられたオブジェクトがデータベースから検索されたことがある場合は、キャッシュされたものを返します。キャッシュを読み出さずにデータベースから直接読み込ませたい場合は、親オブジェクトが持つ\#reload_associationメソッドを呼び出します。

```Plain
@author = @book.reload_author
```

### [4.1.1.2 association=(associate)](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-association-associate)

association=メソッドは、引数のオブジェクトをそのオブジェクトに関連付けます。その背後では、関連付けられたオブジェクトから主キーを取り出し、そのオブジェクトの外部キーにその同じ値を設定しています。

```Plain
@book.author = @author
```

### [4.1.1.3 build_association(attributes = {})](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-build-association-attributes)

build_associationメソッドは、関連付けられた型の新しいオブジェクトを返します。返されるオブジェクトは、渡された属性に基いてインスタンス化され、外部キーを経由するリンクが設定されます。関連付けられたオブジェクトは、値が返された時点ではまだ保存されて_いない_ことにご注意ください。

```Plain
@author = @book.build_author(author_number: 123,
                                  author_name: "John Doe")
```

### [4.1.1.4 create_association(attributes = {})](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-create-association-attributes)

create_associationメソッドは、関連付けられた型の新しいオブジェクトを返します。このオブジェクトは、渡された属性を用いてインスタンス化され、そのオブジェクトの外部キーを介してリンクが設定されます。そして、関連付けられたモデルで指定されている検証がすべてパスすると、この関連付けられたオブジェクトは保存されます。

```Plain
@author = @book.create_author(author_number: 123,
                                  author_name: "John Doe")
```

### [4.1.1.5 create_association!(attributes = {})](https://railsguides.jp/association_basics.html#belongs-to%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-create-association-bang-attributes)

上のcreate_associationと同じですが、レコードがinvalidの場合にActiveRecord::RecordInvalidがraiseされる点が異なります。

### [**4.1.2 belongs_toのオプション**](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3)

Railsのデフォルトのbelongs_to関連付けは、ほとんどの場合カスタマイズ不要ですが、関連付けの動作をカスタマイズしたい場合もあります。これは、作成するときに渡すオプションとスコープブロックで簡単にカスタマイズできます。たとえば、以下のようなオプションを関連付けに追加できます。

```Plain
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at,
    counter_cache: true
end
```

belongs_to関連付けでは以下のオプションがサポートされています。

- :autosave
- :class_name
- :counter_cache
- :dependent
- :foreign_key
- :primary_key
- :inverse_of
- :polymorphic
- :touch
- :validate
- :optional

### [4.1.2.1 :autosave](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-autosave)

:autosaveオプションをtrueに設定すると、親オブジェクトが保存されるたびに、読み込まれているすべての関連付けメンバを保存し、destroyフラグが立っているメンバを破棄します。:autosaveをfalseに設定することと、:autosaveオプションを未設定のままにしておくことは同じではありません。:autosaveが存在しない場合、関連付けられたオブジェクトのうち、新しいオブジェクトは保存されますが、更新されたオブジェクトは保存されません。

### [4.1.2.2 :class_name](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-class-name)

関連名から関連相手のオブジェクト名を生成できない事情がある場合、:class_nameオプションを用いてモデル名を直接指定できます。たとえば、書籍(book)が著者(author)に従属しているが実際の著者のモデル名がPatronである場合には、以下のように指定します。

```Plain
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron"
end
```

### [4.1.2.3 :counter_cache](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-counter-cache)

:counter_cacheオプションは、従属しているオブジェクトの数の検索効率を向上させます。以下のモデルで説明します。

```Plain
class Book < ApplicationRecord
  belongs_to :author
end
class Author < ApplicationRecord
  has_many :books
end
```

上の宣言のままでは、@author.books.sizeの値を知るためにデータベースに対してCOUNT(*)クエリを実行する必要があります。この呼び出しを避けるために、「従属している方のモデル(belongs_toを宣言している方のモデル)」にカウンタキャッシュを追加できます。

```Plain
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end
class Author < ApplicationRecord
  has_many :books
end
```

上のように宣言すると、キャッシュ値が最新の状態に保たれ、次にsizeメソッドが呼び出されたときにその値が返されます。

ここで1つ注意が必要です。:counter_cacheオプションはbelongs_to宣言で指定しますが、実際に数を数えたいカラムは「相手の」モデル(関連付けられているモデル)の方に追加する必要があります。上の場合には、Authorモデルの方にbooks_countカラムを追加する必要があります。

counter_cacheオプションでtrueの代わりに任意のカラム名を設定すると、デフォルトのカラム名をオーバーライドできます。以下は、books_countの代わりにcount_of_booksを設定した場合の例です。

```Plain
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end
class Author < ApplicationRecord
  has_many :books
end
```

belongs_toの関連付けをする時に、:counter_cacheオプションを設定する必要があります。

カウンタキャッシュ用のカラムは、attr_readonlyによって読み出し専用属性となるモデルのリストに追加されます。

### [4.1.2.4 :dependent](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-dependent)

:dependentで指定するオプションの挙動は以下のとおりです。

- :destroy: オブジェクトが削除されるときに、関連付けられたオブジェクトのdestroyメソッドが実行されます。
- :delete: オブジェクトが削除されるときに、関連付けられたオブジェクトが直接データベースから削除されます。destroyメソッドは実行されません。

このオプションは、他のクラスのhas_many関連付けとつながりのあるbelongs_to関連付けに対して使ってはいけません。孤立したレコードがデータベースに残ってしまう可能性があります。

### [4.1.2.5 :foreign_key](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-foreign-key)

Railsの慣例では、相手のモデルを指す外部キーを保持しているjoinテーブル上のカラム名については、そのモデル名にサフィックス_idを追加した関連付け名が使われることを前提とします。:foreign_keyオプションを使えば、外部キーの名前を直接指定できます。

```Plain
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron",
                        foreign_key: "patron_id"
end
```

Railsは外部キーのカラムを自動的に作成することはありません。外部キーを使うには、マイグレーションで明示的に定義する必要があります。

### [4.1.2.6 :primary_key](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-primary-key)

Railsの慣例では、idカラムはそのテーブルの主キーとして使われます。:primary_keyオプションを指定すると、指定された別のカラムを主キーとして設定できます

たとえば、 usersテーブルにguidという主キーがあるとします。そのguidカラムに、別のtodosテーブルの外部キーであるuser_idカラムを使いたい場合は、次のようにprimary_keyを設定します。

```Plain
class User < ApplicationRecord
  self.primary_key = 'guid' # 主キーがguidになる
end
class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
```

@user.todos.createを実行すると、@todoレコードはuser_idを@userのguidとして持つようになります。

### [4.1.2.7 :inverse_of](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-inverse-of)

:inverse_ofオプションは、その関連付けの逆関連付けとなるhas_many関連付けまたはhas_one関連付けの名前を指定します。

```Plain
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end
class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

### [4.1.2.8 :polymorphic](https://railsguides.jp/association_basics.html#polymorphic)

:polymorphicオプションにtrueを指定すると、ポリモーフィック関連付けを指定できます。ポリモーフィック関連付けの詳細については[このガイドの説明](https://railsguides.jp/association_basics.html#%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)を参照してください。

### [4.1.2.9 :touch](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-touch)

:touchオプションをtrueに設定すると、そのオブジェクトがsaveまたはdestroyされたときに、関連付けられたオブジェクトのupdated_atタイムスタンプやupdated_onタイムスタンプが常に現在の時刻に設定されます。

```Plain
class Book < ApplicationRecord
  belongs_to :author, touch: true
end
class Author < ApplicationRecord
  has_many :books
end
```

上の例の場合、Bookクラスは、関連付けられているAuthorのタイムスタンプを保存時またはdestroy時に更新します。更新時に特定のタイムスタンプ属性を指定することもできます。

```Plain
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
```

### [4.1.2.10 :validate](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-validate)

:validateオプションをtrueに設定すると、関連付けられたオブジェクトが保存時に必ず検証(validation)されます。デフォルトはfalseであり、この場合関連付けられたオブジェクトは保存時に検証されません。

### [4.1.2.11 :optional](https://railsguides.jp/association_basics.html#optional)

:optionalオプションをtrueに設定すると、関連付けされたオブジェクトの存在性のバリデーションが実行されないようになります。デフォルトではこのオプションはfalseとなっています。

### [**4.1.3 belongs_toのスコープ**](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97)

belongs_toで使われるクエリをカスタマイズしたい場合があります。スコープブロックを用いてこのようなカスタマイズを行えます。以下に例を示します。

```Plain
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```

スコープブロック内では標準の[クエリメソッド](https://railsguides.jp/active_record_querying.html)をすべて利用できます。ここでは以下について説明します。

- where
- includes
- readonly
- select

### [4.1.3.1 where](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97-where)

whereは、関連付けられるオブジェクトが満たすべき条件を指定します。

```Plain
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```

### [4.1.3.2 includes](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97-includes)

includesメソッドを使うと、その関連付けが使われるときにeager-load (訳注:preloadとは異なる)しておきたい第2関連付けを指定できます。以下のモデルを例に考えてみましょう。

```Plain
class Chapter < ApplicationRecord
  belongs_to :book
end
class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end
class Author < ApplicationRecord
  has_many :books
end
```

chaptersから著者名(Author)を@chapter.book.authorのように直接取り出す頻度が高い場合は、chapterからbookへの関連付けを行なう時にAuthorをあらかじめincludesしておくと、無駄なクエリが減って効率が高まります。

```Plain
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end
class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end
class Author < ApplicationRecord
  has_many :books
end
```

直接の関連付けではincludesを使う必要はありません。Book belongs_to :authorのような直接の関連付けでは必要に応じて自動的にeager-loadされます。

### [4.1.3.3 readonly](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97-readonly)

readonlyを指定すると、関連付けられたオブジェクトから取り出した内容は読み出し専用になります。

### [4.1.3.4 select](https://railsguides.jp/association_basics.html#belongs-to%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97-select)

selectメソッドを使うと、関連付けられたオブジェクトのデータ取り出しに使われるSQLのSELECT句を上書きします。Railsはデフォルトではすべてのカラムを取り出します。

selectをbelongs_to関連付けで使う場合、正しい結果を得るために:foreign_keyオプションを必ず設定してください。

### [**4.1.4 関連付けられたオブジェクトが存在するかどうかを確認する**](https://railsguides.jp/association_basics.html#belongs-to%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0-%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%89%E3%82%8C%E3%81%9F%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%AD%98%E5%9C%A8%E3%81%99%E3%82%8B%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B)

association.nil?メソッドを用いて、関連付けられたオブジェクトが存在するかどうかを確認できます。

```Plain
if @book.author.nil?
  @msg = "この本の著者が見つかりません"
end
```

### [**4.1.5 オブジェクトが保存されるタイミング**](https://railsguides.jp/association_basics.html#belongs-to%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E4%BF%9D%E5%AD%98%E3%81%95%E3%82%8C%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0)

オブジェクトをbelongs_to関連付けに割り当てても、そのオブジェクトが自動的に保存されるわけでは_ありません_。関連付けられたオブジェクトが保存されることもありません。

### [**4.2 has_one関連付けの詳細**](https://railsguides.jp/association_basics.html#has-one%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0)

has_one関連付けは他のモデルと1対1対応します。データベースの観点では、この関連付けでは相手のクラスが外部キーを持ちます。相手ではなく自分のクラスが外部キーを持っているのであれば、belongs_toを使うべきです。

### [**4.2.1 has_oneで追加されるメソッド**](https://railsguides.jp/association_basics.html#has-one%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89)

has_one関連付けを宣言したクラスでは、以下の6つのメソッドを自動的に利用できるようになります。

- association
- association=(associate)
- build_association(attributes = {})
- create_association(attributes = {})
- create_association!(attributes = {})
- reload_association

これらのメソッドのうち、associationの部分はプレースホルダであり、has_oneの最初の引数である関連付け名をシンボルにしたものに置き換えられます。たとえば以下の宣言を見てみましょう。

```Plain
class Supplier < ApplicationRecord
  has_one :account
end
```

これにより、Supplierモデルのインスタンスで以下のメソッドが使えるようになります。

```Plain
account
account=
build_account
create_account
create_account!
reload_account
```

新しく作成したhas_one関連付けまたはbelongs_to関連付けを初期化するには、build_で始まるメソッドを使う必要があります。この場合has_many関連付けやhas_and_belongs_to_many関連付けで使われるassociation.buildメソッドは使わないでください。作成するには、create_で始まるメソッドをお使いください。

### [4.2.1.1 association](https://railsguides.jp/association_basics.html#has-one%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-association)

associationメソッドは関連付けられたオブジェクトを返します。関連付けられたオブジェクトがない場合はnilを返します。

```Plain
@account = @supplier.account
```

関連付けられたオブジェクトがデータベースから検索されたことがある場合は、キャッシュされたものを返します。キャッシュを読み出さずにデータベースから直接読み込ませたい場合は、親オブジェクトが持つ\#reload_associationメソッドを呼び出します。

```Plain
@account = @supplier.reload_account
```

### [4.2.1.2 association=(associate)](https://railsguides.jp/association_basics.html#has-one%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-association-associate)

association=メソッドは、引数のオブジェクトをそのオブジェクトに関連付けます。その背後では、そのオブジェクトから主キーを取り出し、関連付けるオブジェクトの外部キーの値をその主キーと同じ値にします。

```Plain
@supplier.account = @account
```

### [4.2.1.3 build_association(attributes = {})](https://railsguides.jp/association_basics.html#has-one%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-build-association-attributes)

build_associationメソッドは、関連付けられた型の新しいオブジェクトを返します。このオブジェクトは、渡された属性でインスタンス化され、そのオブジェクトの外部キーを介してリンクが設定されます。ただし、関連付けられたオブジェクトはまだ保存されません。

```Plain
@account = @supplier.build_account(terms: "Net 30")
```

### [4.2.1.4 create_association(attributes = {})](https://railsguides.jp/association_basics.html#has-one%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-create-association-attributes)

create_associationメソッドは、関連付けられた型の新しいオブジェクトを返します。このオブジェクトは、渡された属性を用いてインスタンス化され、そのオブジェクトの外部キーを介してリンクが設定されます。そして、関連付けられたモデルで指定されている検証がすべてパスすると、この関連付けられたオブジェクトは保存されます。

```Plain
@account = @supplier.create_account(terms: "Net 30")
```

### [4.2.1.5 create_association!(attributes = {})](https://railsguides.jp/association_basics.html#has-one%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89-create-association-bang-attributes)

上のcreate_associationと同じですが、レコードがinvalidの場合にActiveRecord::RecordInvalidがraiseされる点が異なります。

### [**4.2.2 has_oneのオプション**](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3)

Railsのデフォルトのhas_one関連付けは、ほとんどの場合カスタマイズ不要ですが、時には関連付けの動作をカスタマイズしたくなることもあると思います。これは、作成するときにオプションを渡すことで簡単にカスタマイズできます。たとえば、以下のようなオプションを関連付けに追加できます。

```Plain
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing", dependent: :nullify
end
```

has_one関連付けでは以下のオプションがサポートされます。

- :as
- :autosave
- :class_name
- :dependent
- :foreign_key
- :inverse_of
- :primary_key
- :source
- :source_type
- :through
- :validate

### [4.2.2.1 :as](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-as)

:asオプションを設定すると、ポリモーフィック関連付けを指定できます。ポリモーフィック関連付けの詳細については[このガイドの説明](https://railsguides.jp/association_basics.html#%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)を参照してください。

### [4.2.2.2 :autosave](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-autosave)

:autosaveオプションをtrueに設定すると、親オブジェクトが保存されるたびに、読み込まれているすべてのメンバを保存し、destroyフラグが立っているメンバを破棄します。:autosaveをfalseに設定することと、:autosaveオプションを未設定のままにしておくことは同じではありません。:autosaveが存在しない場合、関連付けられたオブジェクトのうち、新しいオブジェクトは保存されますが、更新されたオブジェクトは保存されません。

### [4.2.2.3 :class_name](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-class-name)

関連名から関連相手のオブジェクト名を生成できない事情がある場合、:class_nameオプションを用いてモデル名を直接指定できます。たとえば、Supplierにアカウントが1つあり、アカウントを含むモデルの実際の名前がAccountではなくBillingになっている場合、以下のようにモデル名を指定できます。

```Plain
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing"
end
```

### [4.2.2.4 :dependent](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-dependent)

オブジェクトのオーナーがdestroyされたときの、それに関連付けられたオブジェクトの扱いを制御します。

- :destroyを指定すると、関連付けられたオブジェクトも同時にdestroyされます。
- :deleteを指定すると、関連付けられたオブジェクトはデータベースから直接削除されます。このときコールバックは実行されません。
- :nullifyを指定すると、外部キーがNULLに設定されます。ポリモーフィックなtypeカラムもポリモーフィック関連付けでNULLに設定されます。コールバックは実行されません。
- :restrict_with_exceptionを指定すると、関連付けられたレコードがある場合にActiveRecord::DeleteRestrictionError例外が発生します。
- :restrict_with_errorを指定すると、関連付けられたオブジェクトがある場合にエラーがオーナーに追加されます。

NOT NULLデータベース制約のある関連付けでは、:nullifyオプションを与えないようにする必要があります。そのような関連付けをdestroyするdependentを設定しなかった場合、関連付けられたオブジェクトを変更できなくなってしまいます。これは、最初に関連付けられたオブジェクトの外部キーがNULL値になってしまい、この値は許されていないためです。

### [4.2.2.5 :foreign_key](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-foreign-key)

Railsの慣例では、相手のモデル上の外部キーを保持しているカラム名については、そのモデル名にサフィックス_idを追加した関連付け名が使われることを前提とします。:foreign_keyオプションを使うと外部キーの名前を直接指定使うできます。

```Plain
class Supplier < ApplicationRecord
  has_one :account, foreign_key: "supp_id"
end
```

Railsは外部キーのカラムを自動的に作成することはありません。外部キーを使うには、マイグレーションで明示的に定義する必要があります。

### [4.2.2.6 :inverse_of](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-inverse-of)

:inverse_ofオプションは、その関連付けの逆関連付けとなるbelongs_to関連付けの名前を指定します。

```Plain
class Supplier < ApplicationRecord
  has_one :account, inverse_of: :supplier
end
class Account < ApplicationRecord
  belongs_to :supplier, inverse_of: :account
end
```

### [4.2.2.7 :primary_key](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-primary-key)

Railsの慣例では、モデルの主キーはidカラムに保存されていることを前提とします。:primary_keyオプションで主キーを明示的に指定することでこれを上書きできます。

### [4.2.2.8 :source](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-source)

:sourceオプションは、has_one :through関連付けにおける「ソースの」関連付け名、つまり関連付け元の名前を指定します。

### [4.2.2.9 :source_type](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-source-type)

:source_typeオプションは、ポリモーフィック関連付けを介して行われるhas_one :through関連付けにおける「ソースの」関連付けタイプ、つまり関連付け元のタイプを指定します。

```Plain
class Book < ApplicationRecord
  has_one :format, polymorphic: true
  has_one :dust_jacket, through: :format, source: :dust_jacket, source_type: "Hardback"
end
class Paperback < ApplicationRecord; end
class Hardback < ApplicationRecord
  has_one :dust_jacket
end
class DustJacket < ApplicationRecord; end
```

### [4.2.2.10 :through](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-through)

:throughオプションは、[このガイドで既に説明した](https://railsguides.jp/association_basics.html#has-one-through%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)has_one :through関連付けのクエリを実行する際に経由するjoinモデルを指定します。

### [4.2.2.11 :touch](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-touch)

:touchオプションをtrueに設定すると、そのオブジェクトがsaveまたはdestroyされたときに、関連付けられたオブジェクトのupdated_atタイムスタンプやupdated_onタイムスタンプが常に現在の時刻に設定されます。

```Plain
class Supplier < ApplicationRecord
  has_one :account, touch: true
end
class Account < ApplicationRecord
  belongs_to :supplier
end
```

上の場合、supplierをsaveした場合もdestroyした場合も、関連付けられたaccountでタイムスタンプが更新されます。この更新で特定のタイムスタンプ属性を指定することもできます。

```Plain
class Supplier < ApplicationRecord
  has_one :account, touch: :suppliers_updated_at
end
```

### [4.2.2.12 :validate](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3-validate)

:validateオプションをtrueに設定すると、関連付けられたオブジェクトが保存時に必ず検証(validation)されます。デフォルトはfalseであり、この場合関連付けられたオブジェクトは保存時に検証されません。

### [**4.2.3 has_oneのスコープについて**](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)

has_oneで使われるクエリをカスタマイズしたい場合があります。スコープブロックを用いてこのようなカスタマイズを行えます。以下に例を示します。

```Plain
class Supplier < ApplicationRecord
  has_one :account, -> { where active: true }
end
```

スコープブロック内では標準の[クエリメソッド](https://railsguides.jp/active_record_querying.html)をすべて利用できます。ここでは以下について説明します。

- where
- includes
- readonly
- select

### [4.2.3.1 where](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-where)

whereは、関連付けられるオブジェクトが満たすべき条件を指定します。

```Plain
class Supplier < ApplicationRecord
  has_one :account, -> { where "confirmed = 1" }
end
```

### [4.2.3.2 includes](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-includes)

includesメソッドを使うと、その関連付けが使われるときにeager-loadすべき第2関連付けを指定できます。以下のモデルを例に考えてみましょう。

```Plain
class Supplier < ApplicationRecord
  has_one :account
end
class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ApplicationRecord
  has_many :accounts
end
```

上の例で、Supplierから代表(Representative)を@supplier.account.representativeのように直接取り出す頻度が高い場合は、SupplierからAccountへの関連付けにRepresentativeをあらかじめincludeしておくと、無駄なクエリが減って効率が高まります。

```Plain
class Supplier < ApplicationRecord
  has_one :account, -> { includes :representative }
end
class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end
class Representative < ApplicationRecord
  has_many :accounts
end
```

### [4.2.3.3 readonly](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-readonly)

readonlyを指定すると、関連付けられたオブジェクトを取り出すときに読み出し専用になります。

### [4.2.3.4 select](https://railsguides.jp/association_basics.html#has-one%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-select)

selectメソッドを使うと、関連付けられたオブジェクトのデータ取り出しに使われるSQLのSELECT句を上書きします。Railsはデフォルトではすべてのカラムを取り出します。

### [**4.2.4 関連付けられたオブジェクトが存在するかどうかを確認する**](https://railsguides.jp/association_basics.html#has-one%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0-%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%82%89%E3%82%8C%E3%81%9F%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E5%AD%98%E5%9C%A8%E3%81%99%E3%82%8B%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B)

association.nil?メソッドを用いて、関連付けられたオブジェクトが存在するかどうかを確認できます。

```Plain
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
```

### [**4.2.5 オブジェクトが保存されるタイミング**](https://railsguides.jp/association_basics.html#has-one%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E4%BF%9D%E5%AD%98%E3%81%95%E3%82%8C%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0)

has_one関連付けにオブジェクトをアサインすると、外部キーを更新するためにそのオブジェクトは自動的に保存されます。さらに、置き換えられるオブジェクトは、これは外部キーが変更されたことによってすべて自動的に保存されます。

関連付けられているオブジェクト同士のいずれか一方が検証(validation)のために保存に失敗すると、アサインの状態からはfalseが返され、アサインはキャンセルされます。

親オブジェクト(has_one関連付けを宣言している側のオブジェクト)が保存されない場合(つまりnew_record?がtrueを返す場合)、子オブジェクトは追加時に保存されません。親オブジェクトが保存された場合は、子オブジェクトは保存されます。

has_one関連付けにオブジェクトをアサインし、しかもそのオブジェクトを保存したくない場合、build_associationメソッドをお使いください。

### [**4.3 has_many関連付けの詳細**](https://railsguides.jp/association_basics.html#has-many%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91%E3%81%AE%E8%A9%B3%E7%B4%B0)

has_many関連付けは、他のモデルとの間に「1対多」のつながりを作成します。データベースの観点では、この関連付けにおいては相手のクラスが外部キーを持ちます。この外部キーは相手のクラスのインスタンスを参照します。

### [**4.3.1 has_manyで追加されるメソッド**](https://railsguides.jp/association_basics.html#has-many%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89)

has_many関連付けを宣言したクラスでは、以下の17のメソッドを自動的に利用できるようになります。

- collection
- collection<<(object, ...)
- collection.delete(object, ...)
- collection.destroy(object, ...)

＞あ、これとCollectionはつながってたのか。

NOT NULL制約に対し、逆のパターンであるNULL制約があります。 これは、列がNULLでなければならないということではありません。 そのような制約は意味がありません。 この制約は、列がNULLであってもよいというデフォルトの振舞いを選択するだけのものです。