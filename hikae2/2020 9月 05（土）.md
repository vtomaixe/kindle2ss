---
Created: 2020-09-05T17:58
Updated: 2020-09-05T17:58
---
ラムダとプロクのリターン時ネクスト、ブレイク時の違い

2020 9月 05（土）,17:58

継承と入れ子は別物

2020 9月 05（土）,18:01

&をつけるから、プロクオブジェクトがブロックになる

無ければプロクオブジェクトのまま

2020 9月 05（土）,18:03

継承チェーンと入れ子の違いは？

2020 9月 05（土）,18:10

あるいはプロクオブジェクトをコールする

2020 9月 05（土）,18:13

継承とネストの違い

2020 9月 05（土）,18:18

探索しにいくのとScopeが変わる瞬間は別物か？

2020 9月 05（土）,19:22

Procはcallまたは[]で呼び出すことができます。

foo[]

2020 9月 05（土）,19:22

シンボル化とストリング化のメソッドは

2020 9月 05（土）,19:22

いや、存在している場所が優先される

「定数はインスタンスではなくクラスにいる」のが間違った理由だ

2020 9月 05（土）,19:23

メソッドが実行できるか、と定数を参照できるか、の判断基準は違う

2020 9月 05（土）,19:24

直接の親でなくても比較演算子による継承判定式は通る

2020 9月 05（土）,19:29

ソートメソッドは非破壊である

2020 9月 05（土）,19:29

raiseの例外クラスを省略した場合は、RuntimeErrorを発生させます。

rescueの例外クラスを省略した場合は、StandardErrorを捕捉します。

2020 9月 05（土）,19:31

46が分からん

2020 9月 05（土）,19:32

配列の破壊的な変更を禁止しますが、配列の要素の破壊的な変更は禁止していません。

2020 9月 05（土）,19:33

49テストしろ

2020 9月 05（土）,19:34